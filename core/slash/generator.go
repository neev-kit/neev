package slash

import (
	"encoding/json"
	"fmt"
	"strings"
)

// GenerateAgentsMD creates an AGENTS.md file for tools without native slash command support
func GenerateAgentsMD(enabledTools []string, projectName string) string {
	var builder strings.Builder

	builder.WriteString("# Neev AI Agent Instructions\n\n")
	builder.WriteString(fmt.Sprintf("Project: **%s**\n\n", projectName))
	builder.WriteString("This file contains instructions and custom commands for AI coding assistants.\n\n")

	builder.WriteString("## Supported Commands\n\n")
	builder.WriteString("When working with this project, use these commands with your AI assistant:\n\n")

	for cmd, details := range DefaultSlashCommands {
		builder.WriteString(fmt.Sprintf("### `/neev:%s`\n", cmd))
		builder.WriteString(fmt.Sprintf("%s\n\n", details.Description))
		builder.WriteString(fmt.Sprintf("**Usage:** %s\n\n", details.Prompt))
	}

	builder.WriteString("## Tools with Native Support\n\n")
	if len(enabledTools) > 0 {
		builder.WriteString("The following tools have native slash command support:\n\n")
		for _, tool := range enabledTools {
			builder.WriteString(fmt.Sprintf("- **%s**: Slash commands are automatically configured\n", formatToolName(tool)))
		}
	} else {
		builder.WriteString("No AI tools with native slash command support are currently configured.\n")
	}

	builder.WriteString("\n## Fallback Instructions\n\n")
	builder.WriteString("If slash commands are not available, you can request operations using natural language:\n\n")
	builder.WriteString("- \"Generate the project bridge context for me\"\n")
	builder.WriteString("- \"Create a new blueprint for user authentication\"\n")
	builder.WriteString("- \"Analyze the project structure for gaps\"\n")
	builder.WriteString("- \"Generate Cucumber tests for this API\"\n")

	builder.WriteString("\n---\n")
	builder.WriteString("*Generated by Neev. Update with: `neev slash-commands --update`*\n")

	return builder.String()
}

// GenerateSlashCommandManifest creates the slash command manifest for AI tools
func GenerateSlashCommandManifest(toolName string) string {
	var builder strings.Builder

	builder.WriteString(fmt.Sprintf("# Neev Slash Commands for %s\n\n", formatToolName(toolName)))
	builder.WriteString("## Available Commands\n\n")

	for cmd, details := range DefaultSlashCommands {
		formattedCmd := fmt.Sprintf("/neev:%s", cmd)
		builder.WriteString(fmt.Sprintf("### %s\n", formattedCmd))
		builder.WriteString(fmt.Sprintf("**Description:** %s\n\n", details.Description))
		builder.WriteString(fmt.Sprintf("**Usage:** %s\n\n", details.Prompt))
	}

	return builder.String()
}

// GenerateInstructions creates custom instructions for Claude/other AI assistants
func GenerateInstructions(projectName string) string {
	var builder strings.Builder

	builder.WriteString("# Neev Project Instructions\n\n")
	builder.WriteString(fmt.Sprintf("You are helping develop **%s** using Neev, a spec-driven development framework.\n\n", projectName))

	builder.WriteString("## Core Concepts\n\n")
	builder.WriteString("- **Blueprints**: Specifications for features (in `.neev/blueprints/`)\n")
	builder.WriteString("- **Foundation**: Project principles and architecture (in `.neev/foundation/`)\n")
	builder.WriteString("- **Bridge Context**: Aggregated project information for AI consumption\n\n")

	builder.WriteString("## Available Commands\n\n")
	for cmd, details := range DefaultSlashCommands {
		builder.WriteString(fmt.Sprintf("- `/neev:%s` ‚Äî %s\n", cmd, details.Description))
	}

	builder.WriteString("\n## Workflow\n\n")
	builder.WriteString("1. Review the project blueprint using `/neev:bridge`\n")
	builder.WriteString("2. Create new features with `/neev:draft`\n")
	builder.WriteString("3. Check structure with `/neev:inspect`\n")
	builder.WriteString("4. Generate tests with `/neev:cucumber`\n")
	builder.WriteString("5. Create API specs with `/neev:openapi`\n")
	builder.WriteString("6. Prepare for handoff with `/neev:handoff`\n\n")

	builder.WriteString("Always consult the blueprints before implementing features.\n")

	return builder.String()
}

// formatToolName converts tool identifier to display name
func formatToolName(toolName string) string {
	switch strings.ToLower(toolName) {
	case "claude-code":
		return "Claude Code"
	case "codebuddy":
		return "CodeBuddy"
	case "opencode":
		return "OpenCode"
	default:
		// Capitalize first letter of each word
		words := strings.Split(toolName, "-")
		for i, word := range words {
			words[i] = strings.ToUpper(word[:1]) + word[1:]
		}
		return strings.Join(words, " ")
	}
}

// GitHubCopilotCommand represents a single slash command for GitHub Copilot
type GitHubCopilotCommand struct {
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Prompt      string   `json:"prompt"`
	Aliases     []string `json:"aliases,omitempty"`
	Context     string   `json:"context,omitempty"`
	Icon        string   `json:"icon,omitempty"`
}

// GitHubCopilotManifest represents the complete manifest for GitHub Copilot
type GitHubCopilotManifest struct {
	Version     string                          `json:"version"`
	ProjectName string                          `json:"project_name"`
	Description string                          `json:"description"`
	Commands    map[string]GitHubCopilotCommand `json:"commands"`
}

// GenerateGitHubCopilotManifest creates a GitHub Copilot-compatible slash command manifest in JSON format
func GenerateGitHubCopilotManifest(projectName string) (string, error) {
	// Build command map with full metadata
	commands := make(map[string]GitHubCopilotCommand)

	// Map of icon emojis for each command
	icons := map[string]string{
		"bridge":   "üåâ",
		"draft":    "üìã",
		"inspect":  "üîç",
		"cucumber": "ü•í",
		"openapi":  "üìñ",
		"handoff":  "ü§ù",
	}

	for cmd, details := range DefaultSlashCommands {
		commands[fmt.Sprintf("neev:%s", cmd)] = GitHubCopilotCommand{
			Name:        cmd,
			Description: details.Description,
			Prompt:      details.Prompt,
			Aliases:     []string{cmd},
			Context:     fmt.Sprintf("Use this command when you need to %s", strings.ToLower(details.Description)),
			Icon:        icons[cmd],
		}
	}

	manifest := GitHubCopilotManifest{
		Version:     "1.0.0",
		ProjectName: projectName,
		Description: "Neev slash commands for spec-driven development with GitHub Copilot Chat",
		Commands:    commands,
	}

	data, err := json.MarshalIndent(manifest, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal GitHub Copilot manifest: %w", err)
	}

	return string(data), nil
}

// GenerateClaudeSlashCommandFile creates a Claude Code slash command file
func GenerateClaudeSlashCommandFile(command string, details SlashCommand) string {
	var builder strings.Builder

	// Frontmatter
	builder.WriteString("---\n")
	builder.WriteString(fmt.Sprintf("name: Neev: %s\n", strings.Title(details.Name)))
	builder.WriteString(fmt.Sprintf("description: %s\n", details.Description))
	builder.WriteString("category: Neev\n")
	builder.WriteString(fmt.Sprintf("tags: [neev, %s]\n", details.Name))
	builder.WriteString("---\n\n")

	// Markers
	builder.WriteString("<!-- NEEV:START -->\n\n")

	// Command body
	builder.WriteString(fmt.Sprintf("# Neev %s Command\n\n", strings.Title(details.Name)))
	builder.WriteString(fmt.Sprintf("%s\n\n", details.Description))
	builder.WriteString("## Usage\n\n")
	builder.WriteString(fmt.Sprintf("Run this command to %s.\n\n", strings.ToLower(details.Description)))
	builder.WriteString("## Instructions\n\n")
	builder.WriteString(details.Prompt)
	builder.WriteString("\n\n")

	// Add specific instructions based on command
	switch command {
	case "bridge":
		builder.WriteString("1. Analyze the project structure\n")
		builder.WriteString("2. Review all blueprints and foundation files\n")
		builder.WriteString("3. Generate comprehensive context for AI consumption\n")
		builder.WriteString("4. Ensure all specifications are included\n")
	case "draft":
		builder.WriteString("1. Gather requirements for the new feature\n")
		builder.WriteString("2. Create a blueprint with intent, architecture, API spec, and security\n")
		builder.WriteString("3. Validate the blueprint against project principles\n")
		builder.WriteString("4. Save to .neev/blueprints/\n")
	case "inspect":
		builder.WriteString("1. Check for drift between specs and code\n")
		builder.WriteString("2. Identify missing components or inconsistencies\n")
		builder.WriteString("3. Report gaps that need to be addressed\n")
		builder.WriteString("4. Suggest fixes where possible\n")
	case "cucumber":
		builder.WriteString("1. Analyze the blueprint for testable scenarios\n")
		builder.WriteString("2. Generate Gherkin feature files\n")
		builder.WriteString("3. Create step definitions\n")
		builder.WriteString("4. Ensure scenarios cover all requirements\n")
	case "openapi":
		builder.WriteString("1. Extract API specifications from blueprints\n")
		builder.WriteString("2. Generate OpenAPI 3.0 compliant specification\n")
		builder.WriteString("3. Include all endpoints, schemas, and security\n")
		builder.WriteString("4. Validate the generated spec\n")
	case "handoff":
		builder.WriteString("1. Format project context for AI agent consumption\n")
		builder.WriteString("2. Include relevant blueprints and specifications\n")
		builder.WriteString("3. Prepare handoff documentation\n")
		builder.WriteString("4. Ensure context is complete and actionable\n")
	}

	builder.WriteString("\n\n<!-- NEEV:END -->\n")

	return builder.String()
}

// GenerateGitHubCopilotPromptFile creates a GitHub Copilot prompt file
func GenerateGitHubCopilotPromptFile(command string, details SlashCommand) string {
	var builder strings.Builder

	// Frontmatter
	builder.WriteString("---\n")
	builder.WriteString(fmt.Sprintf("description: %s\n", details.Description))
	builder.WriteString("---\n\n")

	// Markers
	builder.WriteString("<!-- NEEV:START -->\n\n")

	// Command body
	builder.WriteString(fmt.Sprintf("# Neev %s Command\n\n", strings.Title(details.Name)))
	builder.WriteString(fmt.Sprintf("%s\n\n", details.Description))
	builder.WriteString("## Usage\n\n")
	builder.WriteString(fmt.Sprintf("Run this command to %s.\n\n", strings.ToLower(details.Description)))
	builder.WriteString("## Instructions\n\n")
	builder.WriteString("$ARGUMENTS\n\n") // Placeholder for user input
	builder.WriteString(details.Prompt)
	builder.WriteString("\n\n")

	// Add specific instructions based on command
	switch command {
	case "bridge":
		builder.WriteString("1. Analyze the project structure\n")
		builder.WriteString("2. Review all blueprints and foundation files\n")
		builder.WriteString("3. Generate comprehensive context for AI consumption\n")
		builder.WriteString("4. Ensure all specifications are included\n")
	case "draft":
		builder.WriteString("1. Gather requirements for the new feature\n")
		builder.WriteString("2. Create a blueprint with intent, architecture, API spec, and security\n")
		builder.WriteString("3. Validate the blueprint against project principles\n")
		builder.WriteString("4. Save to .neev/blueprints/\n")
	case "inspect":
		builder.WriteString("1. Check for drift between specs and code\n")
		builder.WriteString("2. Identify missing components or inconsistencies\n")
		builder.WriteString("3. Report gaps that need to be addressed\n")
		builder.WriteString("4. Suggest fixes where possible\n")
	case "cucumber":
		builder.WriteString("1. Analyze the blueprint for testable scenarios\n")
		builder.WriteString("2. Generate Gherkin feature files\n")
		builder.WriteString("3. Create step definitions\n")
		builder.WriteString("4. Ensure scenarios cover all requirements\n")
	case "openapi":
		builder.WriteString("1. Extract API specifications from blueprints\n")
		builder.WriteString("2. Generate OpenAPI 3.0 compliant specification\n")
		builder.WriteString("3. Include all endpoints, schemas, and security\n")
		builder.WriteString("4. Validate the generated spec\n")
	case "handoff":
		builder.WriteString("1. Format project context for AI agent consumption\n")
		builder.WriteString("2. Include relevant blueprints and specifications\n")
		builder.WriteString("3. Prepare handoff documentation\n")
		builder.WriteString("4. Ensure context is complete and actionable\n")
	}

	builder.WriteString("\n\n<!-- NEEV:END -->\n")

	return builder.String()
}

// GenerateGitHubCopilotPrompts generates all GitHub Copilot prompt files
func GenerateGitHubCopilotPrompts(projectName string) map[string]string {
	files := make(map[string]string)

	for cmd, details := range DefaultSlashCommands {
		fileName := fmt.Sprintf("%s.prompt.md", cmd)
		content := GenerateGitHubCopilotPromptFile(cmd, details)
		files[fileName] = content
	}

	return files
}
func GenerateClaudeSlashCommands(projectName string) map[string]string {
	files := make(map[string]string)

	for cmd, details := range DefaultSlashCommands {
		fileName := fmt.Sprintf("%s.md", cmd)
		content := GenerateClaudeSlashCommandFile(cmd, details)
		files[fileName] = content
	}

	return files
}
