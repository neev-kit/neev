package slash

import (
	"encoding/json"
	"fmt"
	"strings"
)

// GenerateAgentsMD creates an AGENTS.md file for tools without native slash command support
func GenerateAgentsMD(enabledTools []string, projectName string) string {
	var builder strings.Builder

	builder.WriteString("# Neev AI Agent Instructions\n\n")
	builder.WriteString(fmt.Sprintf("Project: **%s**\n\n", projectName))
	builder.WriteString("This file contains instructions and custom commands for AI coding assistants.\n\n")

	builder.WriteString("## Supported Commands\n\n")
	builder.WriteString("When working with this project, use these commands with your AI assistant:\n\n")

	for cmd, details := range DefaultSlashCommands {
		builder.WriteString(fmt.Sprintf("### `/neev:%s`\n", cmd))
		builder.WriteString(fmt.Sprintf("%s\n\n", details.Description))
		builder.WriteString(fmt.Sprintf("**Usage:** %s\n\n", details.Prompt))
	}

	builder.WriteString("## Tools with Native Support\n\n")
	if len(enabledTools) > 0 {
		builder.WriteString("The following tools have native slash command support:\n\n")
		for _, tool := range enabledTools {
			builder.WriteString(fmt.Sprintf("- **%s**: Slash commands are automatically configured\n", formatToolName(tool)))
		}
	} else {
		builder.WriteString("No AI tools with native slash command support are currently configured.\n")
	}

	builder.WriteString("\n## Fallback Instructions\n\n")
	builder.WriteString("If slash commands are not available, you can request operations using natural language:\n\n")
	builder.WriteString("- \"Generate the project bridge context for me\"\n")
	builder.WriteString("- \"Create a new blueprint for user authentication\"\n")
	builder.WriteString("- \"Analyze the project structure for gaps\"\n")
	builder.WriteString("- \"Generate Cucumber tests for this API\"\n")

	builder.WriteString("\n---\n")
	builder.WriteString("*Generated by Neev. Update with: `neev slash-commands --update`*\n")

	return builder.String()
}

// GenerateSlashCommandManifest creates the slash command manifest for AI tools
func GenerateSlashCommandManifest(toolName string) string {
	var builder strings.Builder

	builder.WriteString(fmt.Sprintf("# Neev Slash Commands for %s\n\n", formatToolName(toolName)))
	builder.WriteString("## Available Commands\n\n")

	for cmd, details := range DefaultSlashCommands {
		formattedCmd := fmt.Sprintf("/neev:%s", cmd)
		builder.WriteString(fmt.Sprintf("### %s\n", formattedCmd))
		builder.WriteString(fmt.Sprintf("**Description:** %s\n\n", details.Description))
		builder.WriteString(fmt.Sprintf("**Usage:** %s\n\n", details.Prompt))
	}

	return builder.String()
}

// GenerateInstructions creates custom instructions for Claude/other AI assistants
func GenerateInstructions(projectName string) string {
	var builder strings.Builder

	builder.WriteString("# Neev Project Instructions\n\n")
	builder.WriteString(fmt.Sprintf("You are helping develop **%s** using Neev, a spec-driven development framework.\n\n", projectName))

	builder.WriteString("## Core Concepts\n\n")
	builder.WriteString("- **Blueprints**: Specifications for features (in `.neev/blueprints/`)\n")
	builder.WriteString("- **Foundation**: Project principles and architecture (in `.neev/foundation/`)\n")
	builder.WriteString("- **Bridge Context**: Aggregated project information for AI consumption\n\n")

	builder.WriteString("## Available Commands\n\n")
	for cmd, details := range DefaultSlashCommands {
		builder.WriteString(fmt.Sprintf("- `/neev:%s` ‚Äî %s\n", cmd, details.Description))
	}

	builder.WriteString("\n## Workflow\n\n")
	builder.WriteString("1. Review the project blueprint using `/neev:bridge`\n")
	builder.WriteString("2. Create new features with `/neev:draft`\n")
	builder.WriteString("3. Check structure with `/neev:inspect`\n")
	builder.WriteString("4. Generate tests with `/neev:cucumber`\n")
	builder.WriteString("5. Create API specs with `/neev:openapi`\n")
	builder.WriteString("6. Prepare for handoff with `/neev:handoff`\n\n")

	builder.WriteString("Always consult the blueprints before implementing features.\n")

	return builder.String()
}

// formatToolName converts tool identifier to display name
func formatToolName(toolName string) string {
	switch strings.ToLower(toolName) {
	case "claude-code":
		return "Claude Code"
	case "codebuddy":
		return "CodeBuddy"
	case "opencode":
		return "OpenCode"
	default:
		// Capitalize first letter of each word
		words := strings.Split(toolName, "-")
		for i, word := range words {
			words[i] = strings.ToUpper(word[:1]) + word[1:]
		}
		return strings.Join(words, " ")
	}
}

// GitHubCopilotCommand represents a single slash command for GitHub Copilot
type GitHubCopilotCommand struct {
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Prompt      string   `json:"prompt"`
	Aliases     []string `json:"aliases,omitempty"`
	Context     string   `json:"context,omitempty"`
	Icon        string   `json:"icon,omitempty"`
}

// GitHubCopilotManifest represents the complete manifest for GitHub Copilot
type GitHubCopilotManifest struct {
	Version     string                          `json:"version"`
	ProjectName string                          `json:"project_name"`
	Description string                          `json:"description"`
	Commands    map[string]GitHubCopilotCommand `json:"commands"`
}

// GenerateGitHubCopilotManifest creates a GitHub Copilot-compatible slash command manifest in JSON format
func GenerateGitHubCopilotManifest(projectName string) (string, error) {
	// Build command map with full metadata
	commands := make(map[string]GitHubCopilotCommand)

	// Map of icon emojis for each command
	icons := map[string]string{
		"bridge":   "üåâ",
		"draft":    "üìã",
		"inspect":  "üîç",
		"cucumber": "ü•í",
		"openapi":  "üìñ",
		"handoff":  "ü§ù",
	}

	for cmd, details := range DefaultSlashCommands {
		commands[fmt.Sprintf("neev:%s", cmd)] = GitHubCopilotCommand{
			Name:        cmd,
			Description: details.Description,
			Prompt:      details.Prompt,
			Aliases:     []string{cmd},
			Context:     fmt.Sprintf("Use this command when you need to %s", strings.ToLower(details.Description)),
			Icon:        icons[cmd],
		}
	}

	manifest := GitHubCopilotManifest{
		Version:     "1.0.0",
		ProjectName: projectName,
		Description: "Neev slash commands for spec-driven development with GitHub Copilot Chat",
		Commands:    commands,
	}

	data, err := json.MarshalIndent(manifest, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal GitHub Copilot manifest: %w", err)
	}

	return string(data), nil
}
