package tools

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

// SkillContent represents a skill that can be exported to different tools
type SkillContent struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Content     string `json:"content"`
	Type        string `json:"type"` // "command", "snippet", "function", etc.
	Language    string `json:"language,omitempty"`
	Version     string `json:"version"`
}

// Adapter is the interface for tool-specific adapters
type Adapter interface {
	// Name returns the adapter name
	Name() string

	// GenerateSkill converts a SkillContent to tool-specific format
	GenerateSkill(skill SkillContent) (string, error)

	// GenerateConfigFile generates tool-specific config files
	GenerateConfigFile(projectName string, skills []SkillContent) (string, error)

	// GetMetadata returns tool-specific metadata
	GetMetadata() map[string]interface{}
}

// CursorAdapter generates skills for Cursor IDE
type CursorAdapter struct {
	tool *Tool
}

// NewCursorAdapter creates a new Cursor adapter
func NewCursorAdapter(tool *Tool) *CursorAdapter {
	return &CursorAdapter{tool: tool}
}

func (a *CursorAdapter) Name() string {
	return "Cursor"
}

func (a *CursorAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Cursor uses JSON format for skills
	skillData := map[string]interface{}{
		"name":        skill.Name,
		"description": skill.Description,
		"type":        skill.Type,
		"content":     skill.Content,
		"version":     skill.Version,
	}

	data, err := json.MarshalIndent(skillData, "", "  ")
	if err != nil {
		return "", err
	}

	return string(data), nil
}

func (a *CursorAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := map[string]interface{}{
		"version":   "1.0",
		"project":   projectName,
		"skills":    len(skills),
		"generated": true,
		"format":    "cursor",
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return "", err
	}

	return string(data), nil
}

func (a *CursorAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":    a.Name(),
		"native":     a.tool.Config.Native,
		"skillsDir":  a.tool.Config.SkillsDir,
		"configDir":  a.tool.Config.ConfigDir,
		"formatType": "json",
	}
}

// ClaudeAdapter generates skills for Claude
type ClaudeAdapter struct {
	tool *Tool
}

// NewClaudeAdapter creates a new Claude adapter
func NewClaudeAdapter(tool *Tool) *ClaudeAdapter {
	return &ClaudeAdapter{tool: tool}
}

func (a *ClaudeAdapter) Name() string {
	return "Claude"
}

func (a *ClaudeAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Claude uses markdown-based skills
	skillContent := fmt.Sprintf("# Skill: %s\n\n**Description:** %s\n**Type:** %s\n**Version:** %s\n\n## Implementation\n\n%s\n\n## Metadata\n\n- Format: claude\n- Language: %s\n- Category: %s\n",
		skill.Name, skill.Description, skill.Type, skill.Version, skill.Content, skill.Language, skill.Type)

	return skillContent, nil
}

func (a *ClaudeAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := fmt.Sprintf("# Claude Skills Configuration\n\n**Project:** %s\n**Format:** claude\n**Skills Count:** %d\n**Auto-generated:** true\n\n## Available Skills\n\n",
		projectName, len(skills))

	for i, skill := range skills {
		config += fmt.Sprintf("%d. **%s** - %s\n", i+1, skill.Name, skill.Description)
	}

	config += "\n## Notes\n\n- Skills are automatically loaded by Claude\n- Each skill is stored in its own file\n- Use 'neev sync-skills' to regenerate\n\n"

	return config, nil
}

func (a *ClaudeAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":    a.Name(),
		"native":     a.tool.Config.Native,
		"skillsDir":  a.tool.Config.SkillsDir,
		"configDir":  a.tool.Config.ConfigDir,
		"formatType": "markdown",
	}
}

// CopilotAdapter generates skills for GitHub Copilot
type CopilotAdapter struct {
	tool *Tool
}

// NewCopilotAdapter creates a new Copilot adapter
func NewCopilotAdapter(tool *Tool) *CopilotAdapter {
	return &CopilotAdapter{tool: tool}
}

func (a *CopilotAdapter) Name() string {
	return "GitHub Copilot"
}

func (a *CopilotAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Copilot uses markdown format
	skillContent := fmt.Sprintf("# %s\n\n%s\n\n## Type: %s\n## Version: %s\n\n### Content\n\n```%s\n%s\n```\n\n---\n*Generated by Neev for GitHub Copilot*\n",
		skill.Name, skill.Description, skill.Type, skill.Version, skill.Language, skill.Content)

	return skillContent, nil
}

func (a *CopilotAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := fmt.Sprintf("# GitHub Copilot Skills for %s\n\nThis directory contains AI skills and prompts for GitHub Copilot.\n\n## Skills\n\n| Skill | Type | Description |\n|-------|------|-------------|\n",
		projectName)

	for _, skill := range skills {
		config += fmt.Sprintf("| %s | %s | %s |\n", skill.Name, skill.Type, skill.Description)
	}

	config += "\n## Auto-Update\n\nRun 'neev sync-skills' to regenerate all skills.\n\n---\n*Auto-generated by Neev - Spec-Driven Development CLI*\n"

	return config, nil
}

func (a *CopilotAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":    a.Name(),
		"native":     a.tool.Config.Native,
		"skillsDir":  a.tool.Config.SkillsDir,
		"configDir":  a.tool.Config.ConfigDir,
		"formatType": "markdown",
	}
}

// CodeiumAdapter generates skills for Codeium
type CodeiumAdapter struct {
	tool *Tool
}

// NewCodeiumAdapter creates a new Codeium adapter
func NewCodeiumAdapter(tool *Tool) *CodeiumAdapter {
	return &CodeiumAdapter{tool: tool}
}

func (a *CodeiumAdapter) Name() string {
	return "Codeium"
}

func (a *CodeiumAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Codeium uses JSON format
	skillData := map[string]interface{}{
		"id":          skill.Name,
		"title":       skill.Name,
		"description": skill.Description,
		"type":        skill.Type,
		"body":        skill.Content,
		"language":    skill.Language,
		"version":     skill.Version,
	}

	data, err := json.MarshalIndent(skillData, "", "  ")
	if err != nil {
		return "", err
	}

	return string(data), nil
}

func (a *CodeiumAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := map[string]interface{}{
		"version":       "1.0",
		"project":       projectName,
		"skillCount":    len(skills),
		"format":        "codeium",
		"autoGenerated": true,
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return "", err
	}

	return string(data), nil
}

func (a *CodeiumAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":    a.Name(),
		"native":     a.tool.Config.Native,
		"skillsDir":  a.tool.Config.SkillsDir,
		"configDir":  a.tool.Config.ConfigDir,
		"formatType": "json",
	}
}

// FallbackAdapter handles tools without specific adapters
type FallbackAdapter struct {
	tool *Tool
}

// NewFallbackAdapter creates a new Fallback adapter
func NewFallbackAdapter(tool *Tool) *FallbackAdapter {
	return &FallbackAdapter{tool: tool}
}

func (a *FallbackAdapter) Name() string {
	return "Natural Language Fallback"
}

func (a *FallbackAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Fallback uses markdown with natural language instructions
	skillContent := fmt.Sprintf("# Skill: %s\n\n## Description\n%s\n\n## Type\n%s\n\n## Version\n%s\n\n## Implementation\n\n%s\n\n## How to Use\n\n1. Copy the implementation above\n2. Paste into your AI tool's skill/prompt editor\n3. Customize as needed for your environment\n\n## Notes\n\nThis skill was generated by Neev but your AI tool (%s) doesn't have\na native adapter. You may need to manually integrate this skill or\nuse your tool's custom prompt/skill mechanism.\n\nFor better integration, consider using a supported tool or opening\nan issue at https://github.com/neev-kit/neev/issues\n\n---\n*Generated by Neev - Spec-Driven Development CLI*\n",
		skill.Name, skill.Description, skill.Type, skill.Version, skill.Content, a.tool.Name)

	return skillContent, nil
}

func (a *FallbackAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := fmt.Sprintf("# Natural Language Skills Documentation for %s\n\nThis directory contains skills generated by Neev in natural language format.\n\n## Manual Integration Required\n\nYour AI tool (%s) does not have a native Neev adapter. Skills are provided\nin markdown format for manual integration.\n\n## Available Skills\n\n",
		projectName, a.tool.Name)

	for i, skill := range skills {
		config += fmt.Sprintf("%d. **%s** (%s) - %s\n", i+1, skill.Name, skill.Type, skill.Description)
	}

	config += fmt.Sprintf("\n## Integration Steps\n\n1. Open '%s/skills/' directory\n2. Read each skill file in markdown format\n3. Copy the content into your %s tool\n4. Test each skill in your environment\n\n## Auto-Update\n\nRun 'neev sync-skills' to regenerate skills from your blueprints.\n\n## Support\n\nIf %s has a native format, please open an issue:\nhttps://github.com/neev-kit/neev/issues\n\n---\n*Generated by Neev - Spec-Driven Development CLI*\n",
		a.tool.Config.SkillsDir, a.tool.Name, a.tool.Name)

	return config, nil
}

func (a *FallbackAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":        a.Name(),
		"native":         false,
		"skillsDir":      a.tool.Config.SkillsDir,
		"configDir":      a.tool.Config.ConfigDir,
		"formatType":     "markdown",
		"requiresManual": true,
	}
}

// GetAdapter returns the appropriate adapter for a tool
func GetAdapter(tool *Tool) Adapter {
	switch tool.Type {
	case ToolCursor:
		return NewCursorAdapter(tool)
	case ToolClaude:
		return NewClaudeAdapter(tool)
	case ToolCopilot:
		return NewCopilotAdapter(tool)
	case ToolCodeium:
		return NewCodeiumAdapter(tool)
	default:
		return NewFallbackAdapter(tool)
	}
}

// GetAdapters returns adapters for all detected tools
func GetAdapters(tools []Tool) []Adapter {
	var adapters []Adapter
	for i := range tools {
		if tools[i].Installed {
			adapters = append(adapters, GetAdapter(&tools[i]))
		}
	}
	return adapters
}

// WriteSkillToFile writes a skill to the tool's native directory
func WriteSkillToFile(adapter Adapter, skill SkillContent, skillsDir string) error {
	// Create skills directory if it doesn't exist
	if err := os.MkdirAll(skillsDir, 0755); err != nil {
		return fmt.Errorf("failed to create skills directory: %w", err)
	}

	// Generate skill content
	content, err := adapter.GenerateSkill(skill)
	if err != nil {
		return fmt.Errorf("failed to generate skill: %w", err)
	}

	// Determine file extension based on adapter type
	var ext string
	metadata := adapter.GetMetadata()
	if formatType, ok := metadata["formatType"].(string); ok {
		switch formatType {
		case "json":
			ext = ".json"
		case "markdown":
			ext = ".md"
		default:
			ext = ".txt"
		}
	} else {
		ext = ".txt"
	}

	// Write to file
	skillPath := filepath.Join(skillsDir, skill.Name+ext)
	if err := os.WriteFile(skillPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write skill file: %w", err)
	}

	return nil
}
