package tools

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

// SkillContent represents a skill that can be exported to different tools
type SkillContent struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Content     string `json:"content"`
	Type        string `json:"type"` // "command", "snippet", "function", etc.
	Language    string `json:"language,omitempty"`
	Version     string `json:"version"`
}

// Adapter is the interface for tool-specific adapters
type Adapter interface {
	// Name returns the adapter name
	Name() string
	
	// GenerateSkill converts a SkillContent to tool-specific format
	GenerateSkill(skill SkillContent) (string, error)
	
	// GenerateConfigFile generates tool-specific config files
	GenerateConfigFile(projectName string, skills []SkillContent) (string, error)
	
	// GetMetadata returns tool-specific metadata
	GetMetadata() map[string]interface{}
}

// CursorAdapter generates skills for Cursor IDE
type CursorAdapter struct {
	tool *Tool
}

// NewCursorAdapter creates a new Cursor adapter
func NewCursorAdapter(tool *Tool) *CursorAdapter {
	return &CursorAdapter{tool: tool}
}

func (a *CursorAdapter) Name() string {
	return "Cursor"
}

func (a *CursorAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Cursor uses JSON format for skills
	skillData := map[string]interface{}{
		"name":        skill.Name,
		"description": skill.Description,
		"type":        skill.Type,
		"content":     skill.Content,
		"version":     skill.Version,
	}
	
	data, err := json.MarshalIndent(skillData, "", "  ")
	if err != nil {
		return "", err
	}
	
	return string(data), nil
}

func (a *CursorAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := map[string]interface{}{
		"version":  "1.0",
		"project":  projectName,
		"skills":   len(skills),
		"generated": true,
		"format":   "cursor",
	}
	
	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return "", err
	}
	
	return string(data), nil
}

func (a *CursorAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":    a.Name(),
		"native":     a.tool.Config.Native,
		"skillsDir":  a.tool.Config.SkillsDir,
		"configDir":  a.tool.Config.ConfigDir,
		"formatType": "json",
	}
}

// ClaudeAdapter generates skills for Claude
type ClaudeAdapter struct {
	tool *Tool
}

// NewClaudeAdapter creates a new Claude adapter
func NewClaudeAdapter(tool *Tool) *ClaudeAdapter {
	return &ClaudeAdapter{tool: tool}
}

func (a *ClaudeAdapter) Name() string {
	return "Claude"
}

func (a *ClaudeAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Claude uses YAML-like format with markdown-based skills
	skillContent := fmt.Sprintf(`# Skill: %s

**Description:** %s
**Type:** %s
**Version:** %s

## Implementation

%s

## Metadata

- Format: claude
- Language: %s
- Category: %s
`, skill.Name, skill.Description, skill.Type, skill.Version, skill.Content, skill.Language, skill.Type)
	
	return skillContent, nil
}

func (a *ClaudeAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := fmt.Sprintf(`# Claude Skills Configuration

**Project:** %s
**Format:** claude
**Skills Count:** %d
**Auto-generated:** true

## Available Skills

`, projectName, len(skills))
	
	for i, skill := range skills {
		config += fmt.Sprintf("%d. **%s** - %s\n", i+1, skill.Name, skill.Description)
	}
	
	config += `
## Notes

- Skills are automatically loaded by Claude
- Each skill is stored in its own file
- Use 'neev sync-skills' to regenerate

`
	
	return config, nil
}

func (a *ClaudeAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":    a.Name(),
		"native":     a.tool.Config.Native,
		"skillsDir":  a.tool.Config.SkillsDir,
		"configDir":  a.tool.Config.ConfigDir,
		"formatType": "markdown",
	}
}

// CopilotAdapter generates skills for GitHub Copilot
type CopilotAdapter struct {
	tool *Tool
}

// NewCopilotAdapter creates a new Copilot adapter
func NewCopilotAdapter(tool *Tool) *CopilotAdapter {
	return &CopilotAdapter{tool: tool}
}

func (a *CopilotAdapter) Name() string {
	return "GitHub Copilot"
}

func (a *CopilotAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Copilot uses markdown format
	skillContent := fmt.Sprintf(`# %s

%s

## Type: %s
## Version: %s

### Content

\`\`\`%s
%s
\`\`\`

---
*Generated by Neev for GitHub Copilot*
`, skill.Name, skill.Description, skill.Type, skill.Version, skill.Language, skill.Content)
	
	return skillContent, nil
}

func (a *CopilotAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := fmt.Sprintf(`# GitHub Copilot Skills for %s

This directory contains AI skills and prompts for GitHub Copilot.

## Skills

| Skill | Type | Description |
|-------|------|-------------|
`, projectName)
	
	for _, skill := range skills {
		config += fmt.Sprintf("| %s | %s | %s |\n", skill.Name, skill.Type, skill.Description)
	}
	
	config += `

## Auto-Update

Run \`neev sync-skills\` to regenerate all skills.

---
*Auto-generated by Neev - Spec-Driven Development CLI*
`
	
	return config, nil
}

func (a *CopilotAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":    a.Name(),
		"native":     a.tool.Config.Native,
		"skillsDir":  a.tool.Config.SkillsDir,
		"configDir":  a.tool.Config.ConfigDir,
		"formatType": "markdown",
	}
}

// CodeiumAdapter generates skills for Codeium
type CodeiumAdapter struct {
	tool *Tool
}

// NewCodeiumAdapter creates a new Codeium adapter
func NewCodeiumAdapter(tool *Tool) *CodeiumAdapter {
	return &CodeiumAdapter{tool: tool}
}

func (a *CodeiumAdapter) Name() string {
	return "Codeium"
}

func (a *CodeiumAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Codeium uses JSON format
	skillData := map[string]interface{}{
		"id":          skill.Name,
		"title":       skill.Name,
		"description": skill.Description,
		"type":        skill.Type,
		"body":        skill.Content,
		"language":    skill.Language,
		"version":     skill.Version,
	}
	
	data, err := json.MarshalIndent(skillData, "", "  ")
	if err != nil {
		return "", err
	}
	
	return string(data), nil
}

func (a *CodeiumAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := map[string]interface{}{
		"version":       "1.0",
		"project":       projectName,
		"skillCount":    len(skills),
		"format":        "codeium",
		"autoGenerated": true,
	}
	
	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return "", err
	}
	
	return string(data), nil
}

func (a *CodeiumAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":    a.Name(),
		"native":     a.tool.Config.Native,
		"skillsDir":  a.tool.Config.SkillsDir,
		"configDir":  a.tool.Config.ConfigDir,
		"formatType": "json",
	}
}

// FallbackAdapter handles tools without specific adapters
type FallbackAdapter struct {
	tool *Tool
}

// NewFallbackAdapter creates a new Fallback adapter
func NewFallbackAdapter(tool *Tool) *FallbackAdapter {
	return &FallbackAdapter{tool: tool}
}

func (a *FallbackAdapter) Name() string {
	return "Natural Language Fallback"
}

func (a *FallbackAdapter) GenerateSkill(skill SkillContent) (string, error) {
	// Fallback uses markdown with natural language instructions
	skillContent := fmt.Sprintf(`# Skill: %s

## Description
%s

## Type
%s

## Version
%s

## Implementation

%s

## How to Use

1. Copy the implementation above
2. Paste into your AI tool's skill/prompt editor
3. Customize as needed for your environment

## Notes

This skill was generated by Neev but your AI tool (%s) doesn't have
a native adapter. You may need to manually integrate this skill or
use your tool's custom prompt/skill mechanism.

For better integration, consider using a supported tool or opening
an issue at https://github.com/neev-kit/neev/issues

---
*Generated by Neev - Spec-Driven Development CLI*
`, skill.Name, skill.Description, skill.Type, skill.Version, skill.Content, a.tool.Name)
	
	return skillContent, nil
}

func (a *FallbackAdapter) GenerateConfigFile(projectName string, skills []SkillContent) (string, error) {
	config := fmt.Sprintf(`# Natural Language Skills Documentation for %s

This directory contains skills generated by Neev in natural language format.

## ⚠️ Manual Integration Required

Your AI tool (%s) does not have a native Neev adapter. Skills are provided
in markdown format for manual integration.

## Available Skills

`, projectName, a.tool.Name)
	
	for i, skill := range skills {
		config += fmt.Sprintf("%d. **%s** (%s) - %s\n", i+1, skill.Name, skill.Type, skill.Description)
	}
	
	config += fmt.Sprintf(`

## Integration Steps

1. Open \`%s/skills/\` directory
2. Read each skill file in markdown format
3. Copy the content into your %s tool
4. Test each skill in your environment

## Auto-Update

Run \`neev sync-skills\` to regenerate skills from your blueprints.

## Support

If %s has a native format, please open an issue:
https://github.com/neev-kit/neev/issues

---
*Generated by Neev - Spec-Driven Development CLI*
`, a.tool.Config.SkillsDir, a.tool.Name, a.tool.Name)
	
	return config, nil
}

func (a *FallbackAdapter) GetMetadata() map[string]interface{} {
	return map[string]interface{}{
		"adapter":         a.Name(),
		"native":          false,
		"skillsDir":       a.tool.Config.SkillsDir,
		"configDir":       a.tool.Config.ConfigDir,
		"formatType":      "markdown",
		"requiresManual":  true,
	}
}

// GetAdapter returns the appropriate adapter for a tool
func GetAdapter(tool *Tool) Adapter {
	switch tool.Type {
	case ToolCursor:
		return NewCursorAdapter(tool)
	case ToolClaude:
		return NewClaudeAdapter(tool)
	case ToolCopilot:
		return NewCopilotAdapter(tool)
	case ToolCodeium:
		return NewCodeiumAdapter(tool)
	default:
		return NewFallbackAdapter(tool)
	}
}

// GetAdapters returns adapters for all detected tools
func GetAdapters(tools []Tool) []Adapter {
	var adapters []Adapter
	for i := range tools {
		if tools[i].Installed {
			adapters = append(adapters, GetAdapter(&tools[i]))
		}
	}
	return adapters
}

// WriteSkillToFile writes a skill to the tool's native directory
func WriteSkillToFile(adapter Adapter, skill SkillContent, skillsDir string) error {
	// Create skills directory if it doesn't exist
	if err := os.MkdirAll(skillsDir, 0755); err != nil {
		return fmt.Errorf("failed to create skills directory: %w", err)
	}
	
	// Generate skill content
	content, err := adapter.GenerateSkill(skill)
	if err != nil {
		return fmt.Errorf("failed to generate skill: %w", err)
	}
	
	// Determine file extension based on adapter type
	var ext string
	metadata := adapter.GetMetadata()
	if formatType, ok := metadata["formatType"].(string); ok {
		switch formatType {
		case "json":
			ext = ".json"
		case "markdown":
			ext = ".md"
		default:
			ext = ".txt"
		}
	} else {
		ext = ".txt"
	}
	
	// Write to file
	skillPath := filepath.Join(skillsDir, skill.Name+ext)
	if err := os.WriteFile(skillPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write skill file: %w", err)
	}
	
	return nil
}
