package tools
package tools

import (
	"os"
	"path/filepath"
	"testing"













































































































































































































































}	}		t.Error("Should return nil when searching empty list")	if found != nil {	found := FindTool(emptyTools, ToolCursor)	}		t.Error("Should return false for empty tool list")	if HasAnyTool(emptyTools) {	}		t.Error("Should return empty list for empty input")	if len(names) != 0 {	names := GetInstalledToolsNames(emptyTools)	emptyTools := []Tool{}func TestEmptyToolList(t *testing.T) {// TestEmptyToolList tests handling of empty tool lists}	}		}			t.Logf("Info: Skills dir may not be under config dir for %s", tool.Name)		if !stringContains(skillsParent, filepath.Base(tool.Config.ConfigDir)) {		skillsParent := filepath.Dir(tool.Config.SkillsDir)		// Verify skills dir is under config dir	for _, tool := range testTools {	}		},			Config: ToolConfig{SkillsDir: "/home/user/.cursor/skills"},			Path:   "/home/user/.cursor",			Type:   ToolCursor,		{	testTools := []Tool{func TestToolPathValidation(t *testing.T) {// TestToolPathValidation validates tool paths are properly formatted}	}		FindTool(tools, ToolCursor)	for i := 0; i < b.N; i++ {	b.ResetTimer()	}		b.Skip("No tools installed for benchmark")	if len(tools) == 0 {	tools := DetectInstalledTools()func BenchmarkFindTool(b *testing.B) {// BenchmarkFindTool benchmarks finding a tool}	}		DetectInstalledTools()	for i := 0; i < b.N; i++ {func BenchmarkDetectInstalledTools(b *testing.B) {// BenchmarkDetectInstalledTools benchmarks tool detection}	return len(str) > 0 && len(substr) > 0 && str[len(str)-len(substr):] == substrfunc stringContains(str, substr string) bool {// stringContains helper function}	}		}			}				t.Logf("Warning: Tool %s skills dir doesn't contain HOME", tool.Name)				// This is a warning, not always required			if !stringContains(tool.Config.SkillsDir, home) {			// Skills directory should typically be in home		if tool.Installed {	for _, tool := range tools {	tools := DetectInstalledTools()	// Verify tools use home directory paths	}		t.Skip("HOME environment variable not set")	if home == "" {	home := os.Getenv("HOME")func TestHomeDirectoryDetection(t *testing.T) {// TestHomeDirectoryDetection validates home directory usage}	}		}			t.Error("Tool type should not be empty")		if toolType == "" {	for toolType := range validTypes {	}		ToolPerplexity: true,		ToolSupabase:   true,		ToolCodeium:    true,		ToolCopilot:    true,		ToolCursor:     true,		ToolClaude:     true,	validTypes := map[ToolType]bool{func TestToolTypeEnum(t *testing.T) {// TestToolTypeEnum validates ToolType enum values}	}		}				len(results[i]), len(results[0]))			t.Errorf("Inconsistent detection results: got %d and %d tools",		if len(results[i]) != len(results[0]) {	for i := 1; i < 5; i++ {	// All results should be consistent	}		<-done	for i := 0; i < 5; i++ {	// Wait for all to complete	}		}(i)			done <- index			results[index] = DetectInstalledTools()		go func(index int) {	for i := 0; i < 5; i++ {	done := make(chan int, 5)	results := make([][]Tool, 5)	// Run detection multiple times concurrentlyfunc TestDetectionConcurrency(t *testing.T) {// TestDetectionConcurrency tests that multiple detection calls are safe}	}		t.Error("Native should be true for Cursor")	if !tool.Config.Native {	}		t.Error("ConfigDir should not be empty")	if tool.Config.ConfigDir == "" {	}		t.Error("SkillsDir should not be empty")	if tool.Config.SkillsDir == "" {	}		},			CommandName: "cursor",			Native:      true,			ConfigDir:   "/home/user/.cursor",			SkillsDir:   "/home/user/.cursor/skills",		Config: ToolConfig{		Installed: true,		Name:      "Cursor IDE",		Type:      ToolCursor,	tool := &Tool{func TestToolConfig(t *testing.T) {// TestToolConfig validates tool configuration}	}		t.Error("Should return true when tools are installed")	if !HasAnyTool(someTools) {	}		{Type: ToolCursor, Installed: true},	someTools := []Tool{	}		t.Error("Should return false for empty tool list")	if HasAnyTool(noTools) {	noTools := []Tool{}func TestHasAnyTool(t *testing.T) {// TestHasAnyTool tests checking for any installed tools}	}		t.Error("Should not find Codeium when not in list")	if notFound != nil {	notFound := FindTool(testTools, ToolCodeium)	}		t.Error("Failed to find Cursor tool")	if cursor == nil || cursor.Name != "Cursor" {	cursor := FindTool(testTools, ToolCursor)	}		{Type: ToolClaude, Name: "Claude", Installed: true},		{Type: ToolCursor, Name: "Cursor", Installed: true},	testTools := []Tool{func TestFindTool(t *testing.T) {// TestFindTool tests finding a tool by type}	}		t.Errorf("Expected 'Cursor', got '%s'", names[0])	if names[0] != "Cursor" {	}		t.Errorf("Expected 2 names, got %d", len(names))	if len(names) != 2 {	names := GetInstalledToolsNames(testTools)	}		},			Config:    ToolConfig{SkillsDir: "/home/user/.claude/skills"},			Installed: true,			Name:      "Claude",			Type:      ToolClaude,		{		},			Config:    ToolConfig{SkillsDir: "/home/user/.cursor/skills"},			Installed: true,			Name:      "Cursor",			Type:      ToolCursor,		{	testTools := []Tool{func TestGetInstalledToolsNames(t *testing.T) {// TestGetInstalledToolsNames tests getting tool names}	}		}			t.Error("Tool has empty skills directory")		if tool.Config.SkillsDir == "" {		}			t.Error("Tool has empty name")		if tool.Name == "" {		}			t.Errorf("Tool %s marked as uninstalled but returned", tool.Name)		if !tool.Installed {	for _, tool := range tools {	// All returned tools should have basic info	}		t.Error("DetectInstalledTools returned nil")	if tools == nil {	// Should return a slice (may be empty if no tools installed)	tools := DetectInstalledTools()func TestDetectInstalledTools(t *testing.T) {// TestDetectInstalledTools tests the tool detection system)