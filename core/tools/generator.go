package tools

import (
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// SkillsGenerator generates skills for detected tools
type SkillsGenerator struct {
	projectName string
	projectRoot string
	tools       []Tool
	adapters    []Adapter
}

// NewSkillsGenerator creates a new skills generator
func NewSkillsGenerator(projectName, projectRoot string, tools []Tool) *SkillsGenerator {
	adapters := GetAdapters(tools)
	return &SkillsGenerator{
		projectName: projectName,
		projectRoot: projectRoot,
		tools:       tools,
		adapters:    adapters,
	}
}

// GenerateSkills generates skills for all detected tools
func (sg *SkillsGenerator) GenerateSkills(blueprints []SkillContent) error {
	if len(sg.tools) == 0 {
		fmt.Println("No tools detected. Generating natural language fallback documentation...")
		return sg.generateFallbackDocumentation(blueprints)
	}

	fmt.Printf("Generating skills for %d tool(s)...\n", len(sg.tools))

	for i, tool := range sg.tools {
		if !tool.Installed {
			continue
		}

		adapter := sg.adapters[i]
		fmt.Printf("\nğŸ“¦ Generating skills for %s\n", tool.Name)

		// Create skills directory
		skillsDir := tool.Config.SkillsDir
		if err := os.MkdirAll(skillsDir, 0755); err != nil {
			return fmt.Errorf("failed to create skills directory for %s: %w", tool.Name, err)
		}

		// Generate each skill
		for _, skill := range blueprints {
			if err := WriteSkillToFile(adapter, skill, skillsDir); err != nil {
				fmt.Printf("  âš ï¸  Failed to generate skill %s: %v\n", skill.Name, err)
				continue
			}
			fmt.Printf("  âœ“ Generated %s\n", skill.Name)
		}

		// Generate config file
		configContent, err := adapter.GenerateConfigFile(sg.projectName, blueprints)
		if err != nil {
			return fmt.Errorf("failed to generate config for %s: %w", tool.Name, err)
		}

		configPath := filepath.Join(skillsDir, "README.md")
		if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
			return fmt.Errorf("failed to write config for %s: %w", tool.Name, err)
		}
		fmt.Printf("  âœ“ Generated configuration\n")

		// Create index file
		if err := sg.generateIndexFile(adapter, skillsDir, blueprints); err != nil {
			fmt.Printf("  âš ï¸  Failed to generate index: %v\n", err)
		}
	}

	return nil
}

// generateFallbackDocumentation generates documentation for tools without adapters
func (sg *SkillsGenerator) generateFallbackDocumentation(blueprints []SkillContent) error {
	// Create a generic skills directory in .neev
	skillsDir := filepath.Join(sg.projectRoot, ".neev", "skills")
	if err := os.MkdirAll(skillsDir, 0755); err != nil {
		return fmt.Errorf("failed to create skills directory: %w", err)
	}

	fallbackAdapter := NewFallbackAdapter(&Tool{
		Type:      "fallback",
		Name:      "Unsupported Tools",
		Installed: true,
		Config: ToolConfig{
			SkillsDir:   skillsDir,
			ConfigDir:   filepath.Join(sg.projectRoot, ".neev"),
			Native:      false,
			CommandName: "",
		},
	})

	fmt.Println("\nğŸ“„ Generating natural language skills documentation...")

	// Generate each skill in markdown
	for _, skill := range blueprints {
		if err := WriteSkillToFile(fallbackAdapter, skill, skillsDir); err != nil {
			fmt.Printf("  âš ï¸  Failed to generate skill %s: %v\n", skill.Name, err)
			continue
		}
		fmt.Printf("  âœ“ Generated %s.md\n", skill.Name)
	}

	// Generate README
	configContent, err := fallbackAdapter.GenerateConfigFile(sg.projectName, blueprints)
	if err != nil {
		return fmt.Errorf("failed to generate fallback config: %w", err)
	}

	configPath := filepath.Join(skillsDir, "README.md")
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("failed to write fallback config: %w", err)
	}

	fmt.Printf("  âœ“ Generated documentation at %s\n", skillsDir)
	fmt.Println("\nğŸ’¡ Tip: Use 'neev sync-skills' to regenerate skills when blueprints change")

	return nil
}

// generateIndexFile creates an index of all skills
func (sg *SkillsGenerator) generateIndexFile(adapter Adapter, skillsDir string, blueprints []SkillContent) error {
	indexContent := fmt.Sprintf(`# Skills Index for %s

Generated: %s
Tool: %s
Format: %s

## Overview

This directory contains AI skills generated from your Neev blueprints.

## Skills

`, sg.projectName, time.Now().Format("2006-01-02 15:04:05"), adapter.Name(), adapter.GetMetadata()["formatType"])

	for i, skill := range blueprints {
		indexContent += fmt.Sprintf("%d. **%s** - %s\n", i+1, skill.Name, skill.Description)
	}

	indexContent += fmt.Sprintf(`

## Usage

1. Each skill is in its respective file
2. Use %s's native skill/prompt loading mechanism
3. Customize as needed for your project

## Updates

Skills are auto-generated from blueprints. To update:

\`\`\`bash
cd %s
neev sync-skills
\`\`\`

---
*Generated by Neev - Spec-Driven Development CLI*
`, adapter.Name(), sg.projectRoot)

	indexPath := filepath.Join(skillsDir, "INDEX.md")
	return os.WriteFile(indexPath, []byte(indexContent), 0644)
}

// GenerateSummaryReport generates a summary report of all generated skills
func (sg *SkillsGenerator) GenerateSummaryReport(blueprints []SkillContent) string {
	report := fmt.Sprintf(`
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    SKILLS GENERATION SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Project: %s
Location: %s
Generated: %s

TOOLS DETECTED & CONFIGURED
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`, sg.projectName, sg.projectRoot, time.Now().Format("2006-01-02 15:04:05"))

	if len(sg.tools) == 0 {
		report += `
âš ï¸  No AI tools detected. Generating fallback documentation.
    Skills are available in .neev/skills/ in markdown format.
`
	} else {
		for _, tool := range sg.tools {
			if tool.Installed {
				metadata := GetAdapter(&tool).GetMetadata()
				formatType := metadata["formatType"]
				report += fmt.Sprintf(`
âœ“ %s
  Format:     %s
  Location:   %s
  Type:       Native
`, tool.Name, formatType, tool.Config.SkillsDir)
			}
		}
	}

	report += fmt.Sprintf(`

GENERATED SKILLS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total Skills: %d

`, len(blueprints))

	for i, skill := range blueprints {
		report += fmt.Sprintf("%2d. %s (%s)\n", i+1, skill.Name, skill.Type)
	}

	report += `
NEXT STEPS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Open your AI tool and load the skills from the directories above
2. Test each skill in your project
3. Run 'neev sync-skills' to regenerate when blueprints change

DOCUMENTATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- README.md files are in each tool's skills directory
- INDEX.md provides a complete overview
- Natural language fallbacks available if tool isn't supported

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`

	return report
}
