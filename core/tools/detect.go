package tools
package tools











































































































































































































































































































































}	}		}			fmt.Printf("  âœ“ %s (%s/skills)\n", tool.Name, tool.Config.ConfigDir)		if tool.Installed {	for _, tool := range tools {	fmt.Println("Detected AI Tools:")	}		return		fmt.Println("No AI tools detected. Skills will be generated with natural language fallback documentation.")	if len(tools) == 0 {func PrintDetectionSummary(tools []Tool) {// PrintDetectionSummary prints a summary of detected tools}	return false	}		}			return true		if tool.Installed {	for _, tool := range tools {func HasAnyTool(tools []Tool) bool {// HasAnyTool checks if any tools are installed}	return nil	}		}			return &tools[i]		if tool.Type == toolType {	for i, tool := range tools {func FindTool(tools []Tool, toolType ToolType) *Tool {// FindTool finds a tool by type}	return names	}		}			names = append(names, tool.Name)		if tool.Installed {	for _, tool := range tools {	var names []stringfunc GetInstalledToolsNames(tools []Tool) []string {// GetInstalledToolsNames returns a list of installed tool names}	return nil	}		}			},				CommandName: "perplexity",				Native:      true,				ConfigDir:   filepath.Join(home, ".perplexity"),				SkillsDir:   filepath.Join(home, ".perplexity/skills"),			Config: ToolConfig{			Installed: true,			Path:      perplexityPath,			Name:      "Perplexity AI",			Type:      ToolPerplexity,		return &Tool{	if _, err := os.Stat(perplexityPath); err == nil {	perplexityPath := filepath.Join(home, ".perplexity")	// Check for Perplexity config		home := os.Getenv("HOME")func detectPerplexity() *Tool {// detectPerplexity detects Perplexity}	return nil	}		}			},				CommandName: "supabase",				Native:      true,				ConfigDir:   filepath.Join(home, ".supabase"),				SkillsDir:   filepath.Join(home, ".supabase/skills"),			Config: ToolConfig{			Installed: true,			Path:      supabasePath,			Name:      "Supabase",			Type:      ToolSupabase,		return &Tool{	if _, err := os.Stat(supabasePath); err == nil {	supabasePath := filepath.Join(home, ".supabase")	// Check for Supabase CLI		home := os.Getenv("HOME")func detectSupabase() *Tool {// detectSupabase detects Supabase}	return nil	}		}			}				}					}						},							CommandName: "codeium",							Native:      true,							ConfigDir:   filepath.Join(home, ".codeium"),							SkillsDir:   filepath.Join(home, ".codeium/skills"),						Config: ToolConfig{						Installed: true,						Name:      "Codeium",						Type:      ToolCodeium,					return &Tool{				if strings.Contains(entry.Name(), "codeium") {			for _, entry := range entries {		if err == nil {		entries, err := os.ReadDir(vscodeExtPath)	if _, err := os.Stat(vscodeExtPath); err == nil {	vscodeExtPath := filepath.Join(home, ".vscode/extensions")	// Check for Codeium extension		home := os.Getenv("HOME")func detectCodeium() *Tool {// detectCodeium detects Codeium}	return nil	}		}			}				}					}						},							CommandName: "copilot",							Native:      true,							ConfigDir:   filepath.Join(home, ".copilot"),							SkillsDir:   filepath.Join(home, ".copilot/skills"),						Config: ToolConfig{						Installed: true,						Name:      "GitHub Copilot",						Type:      ToolCopilot,					return &Tool{				if strings.Contains(entry.Name(), "github.copilot") {			for _, entry := range entries {		if err == nil {		entries, err := os.ReadDir(vscodeExtPath)	if _, err := os.Stat(vscodeExtPath); err == nil {	vscodeExtPath := filepath.Join(home, ".vscode/extensions")	// Check for Copilot extension in VS Code		home := os.Getenv("HOME")func detectCopilot() *Tool {// detectCopilot detects GitHub Copilot (usually via VS Code)}	return nil	}		}			}				},					CommandName: "claude",					Native:      true,					ConfigDir:   filepath.Join(home, ".claude"),					SkillsDir:   filepath.Join(home, ".claude/skills"),				Config: ToolConfig{				Installed: true,				Path:      path,				Name:      "Claude App",				Type:      ToolClaude,			return &Tool{		if _, err := os.Stat(path); err == nil {	for _, path := range standaloneAPaths {	}		}			filepath.Join(home, "AppData/Local/Claude"),		standaloneAPaths = []string{	case "windows":		}			filepath.Join(home, ".claude"),		standaloneAPaths = []string{	case "linux":		}			filepath.Join(home, "Applications/Claude.app"),		standaloneAPaths = []string{	case "darwin":	switch runtime.GOOS {	var standaloneAPaths []string	// Check for Claude standalone app	}		}			}				}					}						},							CommandName: "claude",							Native:      true,							ConfigDir:   filepath.Join(home, ".claude"),							SkillsDir:   filepath.Join(home, ".claude/skills"),						Config: ToolConfig{						Installed: true,						Name:      "Claude (VS Code)",						Type:      ToolClaude,					return &Tool{				if strings.Contains(entry.Name(), "claude") {			for _, entry := range entries {		if err == nil {		entries, err := os.ReadDir(vscodeExtPath)	if _, err := os.Stat(vscodeExtPath); err == nil {	vscodeExtPath := filepath.Join(home, ".vscode/extensions")	// Check for Claude VS Code extension		home := os.Getenv("HOME")func detectClaude() *Tool {// detectClaude detects Claude for VS Code or Claude App}	return nil	}		}			}				},					CommandName: "cursor",					Native:      true,					ConfigDir:   filepath.Join(home, ".cursor"),					SkillsDir:   filepath.Join(home, ".cursor/skills"),				Config: ToolConfig{				Installed: true,				Path:      path,				Name:      "Cursor",				Type:      ToolCursor,			return &Tool{		if _, err := os.Stat(path); err == nil {	for _, path := range paths {	}		}			"C:/Program Files/Cursor/Cursor.exe",			filepath.Join(home, "AppData/Local/Cursor/Cursor.exe"),		paths = []string{	case "windows":		}			"/opt/cursor/cursor",			filepath.Join(home, ".cursor"),		paths = []string{	case "linux":		}			filepath.Join(home, "Applications/Cursor.app/Contents/MacOS/Cursor"),		paths = []string{	case "darwin":	switch runtime.GOOS {	home := os.Getenv("HOME")	var paths []stringfunc detectCursor() *Tool {// detectCursor detects Cursor IDE}	return tools	}		tools = append(tools, *perplexity)	if perplexity := detectPerplexity(); perplexity != nil {	}		tools = append(tools, *supabase)	if supabase := detectSupabase(); supabase != nil {	}		tools = append(tools, *codeium)	if codeium := detectCodeium(); codeium != nil {	}		tools = append(tools, *copilot)	if copilot := detectCopilot(); copilot != nil {	}		tools = append(tools, *claude)	if claude := detectClaude(); claude != nil {	}		tools = append(tools, *cursor)	if cursor := detectCursor(); cursor != nil {	// Detect each tool type	tools := []Tool{}func DetectInstalledTools() []Tool {// DetectInstalledTools detects all installed AI tools on the system}	CommandName string // How to invoke the tool from CLI	Native      bool   // Whether this is a native tool directory	ConfigDir   string // Directory where config is stored	SkillsDir   string // Directory where skills are storedtype ToolConfig struct {// ToolConfig represents configuration for a tool}	Config      ToolConfig	Installed   bool	Version     string	Path        string	Name        string	Type        ToolTypetype Tool struct {// Tool represents a detected AI tool)	ToolPerplexity ToolType = "perplexity" // Perplexity AI	ToolSupabase  ToolType = "supabase"  // Supabase AI	ToolCodeium   ToolType = "codeium"   // Codeium	ToolCopilot   ToolType = "copilot"   // GitHub Copilot (VS Code)	ToolCursor    ToolType = "cursor"    // Cursor IDE	ToolClaude    ToolType = "claude"    // Claude for VS Code or standalone	// IDE/Tool typesconst (type ToolType string// ToolType represents the type of AI tool/IDE detected)	"strings"	"runtime"	"path/filepath"	"os"	"fmt"import (